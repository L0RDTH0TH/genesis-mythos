<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>World Builder - Genesis Mythos (Fork Prototype)</title>
    <link rel="stylesheet" href="../css/world_builder.css">
    <script src="../js/bridge.js"></script>
    <script defer src="../js/alpine.min.js"></script>
</head>
<body>
    <div class="world-builder-container" x-data="worldBuilder">
        <!-- Top Bar -->
        <div class="top-bar">
            <h1 class="title-label">World Builder – Forging the World (Fork Prototype)</h1>
        </div>

        <!-- Error Message Display -->
        <div x-show="errorMessage" class="error-message-container" style="background: rgba(200, 50, 50, 0.9); color: white; padding: 1rem; margin: 0.5rem; border-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">
            <div style="display: flex; justify-content: space-between; align-items: start;">
                <div style="flex: 1;">
                    <strong style="font-size: 1.1em; display: block; margin-bottom: 0.5rem;" x-text="errorMessage"></strong>
                    <p style="margin: 0; font-size: 0.9em; opacity: 0.9;" x-text="errorDetails"></p>
                </div>
                <button @click="errorMessage = null; errorDetails = null;" style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 0.25rem 0.5rem; border-radius: 3px; cursor: pointer; margin-left: 1rem;">✕</button>
            </div>
        </div>

        <!-- Main Content Area -->
        <div class="main-hsplit">
            <!-- Left Panel: Numbered Tab Bar (BG3-style) -->
            <div class="left-tabs-panel">
                <div class="left-tabs-container">
                    <template x-for="(step, index) in steps" :key="index">
                        <button 
                            class="left-tab-button" 
                            :class="{ 'active': currentStep === index }"
                            @click="setStep(index)">
                            <span class="tab-number" x-text="index + 1"></span>
                            <span class="tab-label" x-text="step.title || `Step ${index + 1}`"></span>
                        </button>
                    </template>
                </div>
            </div>

            <!-- Center Panel: Status/Preview (Fork mode with SVG/canvas preview) -->
            <div class="center-panel" style="background: #1a1a1a; position: relative; display: flex; flex-direction: column; align-items: center; justify-content: center; overflow: hidden;">
                <!-- SVG Preview Container (scalable, layered map preview) -->
                <div id="map-preview" class="svg-preview" x-show="previewMode === 'svg' && previewSvg" x-html="previewSvg" style="width: 100%; height: 100%; overflow: auto; background: #0a0a0a;"></div>
                <!-- Canvas for Azgaar preview rendering (fallback, shown when rendered) -->
                <canvas id="azgaar-canvas" x-show="previewMode === 'canvas' && previewImageUrl" style="width: 100%; height: 100%; object-fit: contain; background: #0a0a0a; display: none;"></canvas>
                <!-- Preview image (fallback if canvas not available, from Godot conversion) -->
                <img id="map-preview-img" x-show="previewMode === 'canvas' && previewImageUrl" :src="previewImageUrl" style="width: 100%; height: 100%; object-fit: contain;" alt="Map Preview">
                <!-- Preview Mode Toggle (shown when preview is available) -->
                <div x-show="(previewSvg || previewImageUrl) && !isGenerating" style="position: absolute; top: 10px; right: 10px; z-index: 10;">
                    <button @click="togglePreviewMode()" class="preview-toggle-button" style="padding: 0.5rem 1rem; background: rgba(0, 0, 0, 0.7); color: #fff; border: 1px solid #666; border-radius: 4px; cursor: pointer;">
                        <span x-text="previewMode === 'svg' ? 'Switch to Canvas' : 'Switch to SVG'"></span>
                    </button>
                </div>
                <!-- Status message (shown when no preview) -->
                <div id="azgaar-status" x-show="!previewSvg && !previewImageUrl" style="padding: 2rem; text-align: center; color: #aaa; font-size: 1.2em;">
                    <p x-text="statusText || 'Azgaar Genesis Fork - Ready'"></p>
                    <p style="font-size: 0.8em; margin-top: 1rem; color: #666;" x-show="!isGenerating">Using modular API - Generate a map to see preview</p>
                </div>
            </div>

            <!-- Right Panel: Parameters (Floating Panel Style) -->
            <div class="right-panel">
                <div class="right-outer-vbox">
                    <!-- Archetype Selector (Top) -->
                    <div class="archetype-selector">
                        <label>Archetype:</label>
                        <select x-model="archetype" @change="loadArchetype($event.target.value)">
                            <template x-for="arch in archetypeNames" :key="arch">
                                <option :value="arch" x-text="arch"></option>
                            </template>
                        </select>
                    </div>

                    <!-- Step Title -->
                    <div class="step-title-section">
                        <h2 class="step-title" x-text="currentStepTitle"></h2>
                    </div>

                    <!-- Parameters Tree (Step-specific curated parameters) -->
                    <div class="param-scroll">
                        <!-- Empty Step Info Text -->
                        <div x-show="currentStepParams.length === 0 && currentStepInfoText" class="empty-step-info">
                            <p class="info-text" x-text="currentStepInfoText"></p>
                        </div>
                        
                        <!-- Parameters List -->
                        <div class="param-list" x-show="currentStepParams.length > 0">
                            <template x-for="param in currentStepParams" :key="param.azgaar_key">
                                <div class="param-row">
                                    <label class="param-label" :title="param.description || ''" x-text="(param.name || param.azgaar_key).replace(/([A-Z])/g, ' $1').trim() + ':'"></label>
                                    <div class="param-control">
                                        <!-- OptionButton -->
                                        <template x-if="param.ui_type === 'OptionButton'">
                                            <select 
                                                x-model="params[param.azgaar_key]"
                                                @change="updateParam(param.azgaar_key, $event.target.value)">
                                                <template x-for="opt in param.options" :key="opt">
                                                    <option :value="opt" x-text="opt"></option>
                                                </template>
                                            </select>
                                        </template>

                                        <!-- HSlider -->
                                        <template x-if="param.ui_type === 'HSlider'">
                                            <div class="slider-container">
                                                <input 
                                                    type="range" 
                                                    x-model.number="params[param.azgaar_key]"
                                                    @input="updateParam(param.azgaar_key, parseFloat($event.target.value))"
                                                    :min="param.clamped_min !== undefined ? param.clamped_min : (param.min || 0)"
                                                    :max="param.clamped_max !== undefined ? param.clamped_max : (param.max || 100)"
                                                    :step="param.step || 1">
                                                <span class="slider-value" x-text="params[param.azgaar_key] || param.default || 0"></span>
                                            </div>
                                        </template>

                                        <!-- SpinBox -->
                                        <template x-if="param.ui_type === 'SpinBox'">
                                            <input 
                                                type="number" 
                                                x-model.number="params[param.azgaar_key]"
                                                @change="updateParam(param.azgaar_key, parseFloat($event.target.value))"
                                                :min="param.min"
                                                :max="param.max"
                                                :step="param.step || 1">
                                        </template>

                                        <!-- CheckBox -->
                                        <template x-if="param.ui_type === 'CheckBox'">
                                            <input 
                                                type="checkbox" 
                                                x-model="params[param.azgaar_key]"
                                                @change="updateParam(param.azgaar_key, $event.target.checked)">
                                        </template>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Bottom Bar: Navigation & Generate -->
        <div class="bottom-bar">
            <button class="nav-button" @click="previousStep()" :disabled="currentStep === 0">Previous</button>
            <button class="nav-button" @click="nextStep()" :disabled="currentStep >= totalSteps - 1">Next</button>
            <button class="generate-button" @click="generate()" :disabled="isGenerating">
                <span x-show="!isGenerating">Generate Map</span>
                <span x-show="isGenerating">Generating...</span>
            </button>
            <div class="progress-container" x-show="isGenerating">
                <div class="progress-bar" :style="'width: ' + progressValue + '%'"></div>
                <span class="progress-text" x-text="statusText || 'Generating...'"></span>
            </div>
        </div>
    </div>

    <!-- Azgaar Genesis Fork Integration -->
    <script type="module">
        /**
         * Azgaar Genesis Fork Integration
         * Uses modular API instead of iframe
         */
        
        // Safety override for accidental large array logging (prevents console overflow)
        const originalLog = console.log;
        const originalError = console.error;
        const originalWarn = console.warn;
        
        console.log = function(...args) {
            const safeArgs = args.map(arg => {
                if (Array.isArray(arg) && arg.length > 100) {
                    return `[Large Array: ${arg.length} items, sample: ${JSON.stringify(arg.slice(0, 5))}...]`;
                }
                if (arg && typeof arg === 'object' && arg.constructor && arg.constructor.name === 'Uint16Array' && arg.length > 100) {
                    return `[TypedArray (${arg.constructor.name}): ${arg.length} items, sample: ${Array.from(arg.slice(0, 5)).join(',')}...]`;
                }
                if (arg && typeof arg === 'object' && arg.constructor && arg.constructor.name === 'Uint8Array' && arg.length > 100) {
                    return `[TypedArray (${arg.constructor.name}): ${arg.length} items, sample: ${Array.from(arg.slice(0, 5)).join(',')}...]`;
                }
                return arg;
            });
            originalLog.apply(console, safeArgs);
        };
        
        console.error = function(...args) {
            const safeArgs = args.map(arg => {
                if (Array.isArray(arg) && arg.length > 100) {
                    return `[Large Array: ${arg.length} items, sample: ${JSON.stringify(arg.slice(0, 5))}...]`;
                }
                if (arg && typeof arg === 'object' && arg.constructor && arg.constructor.name === 'Uint16Array' && arg.length > 100) {
                    return `[TypedArray (${arg.constructor.name}): ${arg.length} items, sample: ${Array.from(arg.slice(0, 5)).join(',')}...]`;
                }
                return arg;
            });
            originalError.apply(console, safeArgs);
        };
        
        console.warn = function(...args) {
            const safeArgs = args.map(arg => {
                if (Array.isArray(arg) && arg.length > 100) {
                    return `[Large Array: ${arg.length} items, sample: ${JSON.stringify(arg.slice(0, 5))}...]`;
                }
                if (arg && typeof arg === 'object' && arg.constructor && arg.constructor.name === 'Uint16Array' && arg.length > 100) {
                    return `[TypedArray (${arg.constructor.name}): ${arg.length} items, sample: ${Array.from(arg.slice(0, 5)).join(',')}...]`;
                }
                return arg;
            });
            originalWarn.apply(console, safeArgs);
        };
        
        // Import Delaunator (peer dependency) from CDN
        import Delaunator from 'https://cdn.jsdelivr.net/npm/delaunator@5.0.1/+esm';
        
        // Import Azgaar Genesis library (updated bundle with SVG rendering)
        import { 
            initGenerator, 
            loadOptions, 
            generateMap, 
            getMapData, 
            renderPreview,
            renderPreviewSVG 
        } from '../js/azgaar/azgaar-genesis.esm.js';

        // Initialize generator with canvas for preview rendering
        const canvas = document.getElementById('azgaar-canvas');
        function resizeCanvas() {
            if (canvas) {
                const container = canvas.parentElement;
                if (container) {
                    canvas.width = container.clientWidth;
                    canvas.height = container.clientHeight;
                    console.log('[Azgaar Genesis] Canvas resized', { width: canvas.width, height: canvas.height });
                }
            }
        }
        
        try {
            if (canvas) {
                // Set initial canvas size
                resizeCanvas();
                
                // Resize on window resize
                window.addEventListener('resize', resizeCanvas);
                
                initGenerator({ canvas: canvas });
                console.log('[Azgaar Genesis] Generator initialized with canvas');
            } else {
                initGenerator({ canvas: null }); // Fallback to headless
                console.log('[Azgaar Genesis] Generator initialized (headless mode - no canvas)');
            }
        } catch (error) {
            console.error('[Azgaar Genesis] Initialization error:', error);
            // Send error to Godot
            if (window.GodotBridge && window.GodotBridge.postMessage) {
                window.GodotBridge.postMessage('map_generation_failed', {
                    error: 'Fork initialization failed: ' + error.message,
                    stack: error.stack
                });
            }
        }
        
        // Store generator functions globally for Alpine.js access
        window.AzgaarGenesis = {
            Delaunator,
            loadOptions,
            generateMap,
            getMapData,
            renderPreview,
            renderPreviewSVG,
            initialized: true
        };
        
        console.log('[Azgaar Genesis] Library loaded and ready');
        
        // Notify Godot that fork is ready via IPC
        if (window.GodotBridge && window.GodotBridge.postMessage) {
            window.GodotBridge.postMessage('fork_ready', {});
            console.log('[Azgaar Genesis] Sent fork_ready IPC message to Godot');
        } else {
            console.warn('[Azgaar Genesis] GodotBridge.postMessage not available - cannot notify Godot');
        }
        
        // Listen for IPC messages from Godot
        if (window.GodotBridge && window.GodotBridge.onMessage) {
            window.GodotBridge.onMessage((message) => {
                console.log('[Azgaar Genesis] Received message from Godot:', message);
                if (message.type === 'generate_map') {
                    handleGenerateMap(message.options || {});
                }
            });
        } else {
            console.warn('[Azgaar Genesis] GodotBridge.onMessage not available');
        }
        
        /**
         * Handle map generation request
         */
        async function handleGenerateMap(options) {
            const statusDiv = document.getElementById('azgaar-status');
            const canvas = document.getElementById('azgaar-canvas');
            const { Delaunator, loadOptions, generateMap, getMapData, renderPreview } = window.AzgaarGenesis;
            
            if (!window.AzgaarGenesis.initialized) {
                console.error('[Azgaar Genesis] Generator not initialized');
                statusDiv.innerHTML = '<p style="color: #f44;">Error: Generator not initialized</p>';
                return;
            }
            
            try {
                statusDiv.innerHTML = '<p>Loading options...</p>';
                console.log('[Azgaar Genesis] Loading options:', options);
                
                loadOptions(options);
                
                statusDiv.innerHTML = '<p>Generating map...</p>';
                console.log('[Azgaar Genesis] Starting generation...');
                
                const startTime = performance.now();
                const data = generateMap(Delaunator);
                const generateTime = performance.now() - startTime;
                
                console.log('[Azgaar Genesis] Generation complete:', {
                    seed: data.seed,
                    time: generateTime.toFixed(2) + 'ms'
                });
                
                statusDiv.innerHTML = '<p>Extracting JSON data...</p>';
                const json = getMapData();
                
                console.log('[Azgaar Genesis] JSON extracted:', {
                    size: JSON.stringify(json).length,
                    hasGrid: !!json.grid,
                    hasPack: !!json.pack
                });
                
                // Render preview (SVG forced by default, canvas fallback only on error)
                let previewDataUrl = '';
                let previewSvgString = '';
                const useSvg = options.use_svg !== false && options.use_svg !== undefined ? options.use_svg : true; // Default to true (forced SVG mode)
                
                // Force SVG rendering (default enabled)
                if (useSvg && window.AzgaarGenesis.renderPreviewSVG) {
                    try {
                        statusDiv.innerHTML = '<p>Rendering SVG preview...</p>';
                        console.log('[Azgaar Genesis] Rendering SVG preview (forced mode)...', { useSvg, hasFunction: !!window.AzgaarGenesis.renderPreviewSVG });
                        
                        const svgContainer = document.getElementById('map-preview');
                        if (!svgContainer) {
                            throw new Error('SVG container element not found');
                        }
                        
                        // Clear previous content
                        svgContainer.innerHTML = '';
                        
                        // Calculate dimensions
                        const containerRect = svgContainer.getBoundingClientRect();
                        const width = containerRect.width > 0 ? containerRect.width : (options.mapWidth || 1024);
                        const height = containerRect.height > 0 ? containerRect.height : (options.mapHeight || 768);
                        
                        console.log('[Azgaar Genesis] SVG container dimensions:', { width, height, containerWidth: containerRect.width, containerHeight: containerRect.height });
                        
                        // Render SVG to container
                        const svgOptions = {
                            container: svgContainer,
                            width: Math.max(width, 512),  // Ensure minimum size
                            height: Math.max(height, 384)
                        };
                        
                        // Call renderPreviewSVG - it should append to container or return string
                        const svgResult = window.AzgaarGenesis.renderPreviewSVG(svgOptions);
                        
                        // Extract SVG string from container (function appends to container)
                        if (svgContainer.firstChild || svgContainer.innerHTML) {
                            previewSvgString = svgContainer.innerHTML;
                        } else if (typeof svgResult === 'string' && svgResult.length > 0) {
                            // Function returned SVG string directly
                            previewSvgString = svgResult;
                            svgContainer.innerHTML = previewSvgString;
                        }
                        
                        if (previewSvgString && previewSvgString.length > 0) {
                            console.log('[Azgaar Genesis] SVG preview rendered successfully, length:', previewSvgString.length);
                            
                            // Update Alpine.js component
                            if (window.worldBuilderInstance) {
                                window.worldBuilderInstance.previewSvg = previewSvgString;
                                window.worldBuilderInstance.previewMode = 'svg';
                            }
                            
                            // Send SVG data to Godot via IPC
                            if (window.GodotBridge && window.GodotBridge.postMessage) {
                                window.GodotBridge.postMessage('svg_preview_ready', {
                                    svgData: previewSvgString,
                                    width: svgOptions.width,
                                    height: svgOptions.height
                                });
                                console.log('[Azgaar Genesis] Sent svg_preview_ready IPC message');
                            }
                        } else {
                            throw new Error('SVG rendering returned empty result');
                        }
                    } catch (svgError) {
                        console.error('[Azgaar Genesis] SVG preview render failed:', svgError, svgError.stack);
                        // Notify Godot of SVG failure
                        if (window.GodotBridge && window.GodotBridge.postMessage) {
                            window.GodotBridge.postMessage('svg_failed', {
                                error: svgError.message,
                                stack: svgError.stack
                            });
                        }
                        // Fall through to canvas rendering as fallback
                        console.warn('[Azgaar Genesis] Falling back to canvas rendering due to SVG failure');
                    }
                } else if (!useSvg) {
                    console.log('[Azgaar Genesis] SVG rendering disabled by options.use_svg = false');
                } else if (!window.AzgaarGenesis.renderPreviewSVG) {
                    console.error('[Azgaar Genesis] renderPreviewSVG function not available');
                }
                
                // Fallback to canvas rendering (only if SVG failed or disabled)
                // DEPRECATED: This is legacy fallback - SVG should be used by default
                if (!previewSvgString && canvas && window.AzgaarGenesis.renderPreview) {
                    try {
                        statusDiv.innerHTML = '<p>Rendering canvas preview (legacy fallback)...</p>';
                        console.warn('[Azgaar Genesis] Using deprecated canvas rendering fallback (SVG preferred)');
                        window.AzgaarGenesis.renderPreview();
                        previewDataUrl = canvas.toDataURL('image/png');
                        // Show canvas after rendering
                        canvas.style.display = 'block';
                        if (statusDiv) {
                            statusDiv.style.display = 'none';
                        }
                        console.log('[Azgaar Genesis] Canvas preview rendered (fallback), data URL length:', previewDataUrl.length);
                        
                        // Update Alpine.js component
                        if (window.worldBuilderInstance) {
                            window.worldBuilderInstance.previewMode = 'canvas';
                            window.worldBuilderInstance.previewImageUrl = previewDataUrl;
                        }
                    } catch (renderError) {
                        console.error('[Azgaar Genesis] Canvas preview render failed:', renderError);
                        statusDiv.innerHTML = '<p style="color: #f44;">Error: Both SVG and canvas rendering failed</p>';
                    }
                } else if (!previewSvgString && useSvg) {
                    // SVG was requested but failed, and no canvas fallback available
                    console.error('[Azgaar Genesis] SVG rendering failed and no canvas fallback available');
                    statusDiv.innerHTML = '<p style="color: #f44;">Error: SVG rendering failed</p>';
                }
                
                // Send to Godot via IPC (with preview if available)
                if (window.GodotBridge && window.GodotBridge.postMessage) {
                    window.GodotBridge.postMessage('map_generated', {
                        data: json,
                        seed: data.seed,
                        generationTime: generateTime,
                        previewDataUrl: previewDataUrl,
                        previewSvg: previewSvgString || null
                    });
                    console.log('[Azgaar Genesis] Sent map_generated message to Godot', {
                        hasCanvasPreview: previewDataUrl.length > 0,
                        hasSvgPreview: previewSvgString.length > 0
                    });
                } else {
                    console.warn('[Azgaar Genesis] GodotBridge.postMessage not available');
                }
                
                // Preview is now visible via canvas rendering
                // Alpine.js will handle showing/hiding based on previewImageUrl
                console.log('[Azgaar Genesis] Generation and preview complete');
            } catch (error) {
                console.error('[Azgaar Genesis] Generation error:', error);
                statusDiv.innerHTML = `
                    <p style="color: #f44;">Error: ${error.message}</p>
                    <p style="font-size: 0.8em; color: #aaa; margin-top: 0.5rem;">${error.stack || ''}</p>
                `;
                
                // Send error to Godot
                if (window.GodotBridge && window.GodotBridge.postMessage) {
                    window.GodotBridge.postMessage('map_generation_failed', {
                        error: error.message,
                        stack: error.stack
                    });
                }
            }
        }
        
        // Make handleGenerateMap available globally for direct calls
        window.handleGenerateMap = handleGenerateMap;
    </script>
    
    <!-- Alpine.js World Builder Controller -->
    <script src="../js/world_builder.js"></script>
</body>
</html>
