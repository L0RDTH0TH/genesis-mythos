<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>World Builder - Genesis Mythos</title>
    <link rel="stylesheet" href="../css/world_builder.css">
    <script src="../js/bridge.js"></script>
    <script defer src="../js/alpine.min.js"></script>
</head>
<body>
    <div class="world-builder-container" x-data="worldBuilder">
        <!-- Top Bar -->
        <div class="top-bar">
            <h1 class="title-label">World Builder – Forging the World</h1>
        </div>

        <!-- Error Message Display -->
        <div x-show="errorMessage" class="error-message-container" style="background: rgba(200, 50, 50, 0.9); color: white; padding: 1rem; margin: 0.5rem; border-radius: 4px; box-shadow: 0 2px 8px rgba(0,0,0,0.3);">
            <div style="display: flex; justify-content: space-between; align-items: start;">
                <div style="flex: 1;">
                    <strong style="font-size: 1.1em; display: block; margin-bottom: 0.5rem;" x-text="errorMessage"></strong>
                    <p style="margin: 0; font-size: 0.9em; opacity: 0.9;" x-text="errorDetails"></p>
                </div>
                <button @click="errorMessage = null; errorDetails = null;" style="background: rgba(255,255,255,0.2); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 0.25rem 0.5rem; border-radius: 3px; cursor: pointer; margin-left: 1rem;">✕</button>
            </div>
        </div>

        <!-- Main Content Area -->
        <div class="main-hsplit">
            <!-- Left Panel: Numbered Tab Bar (BG3-style) -->
            <div class="left-tabs-panel">
                <div class="left-tabs-container">
                    <template x-for="(step, index) in steps" :key="index">
                        <button 
                            class="left-tab-button" 
                            :class="{ 'active': currentStep === index }"
                            @click="setStep(index)">
                            <span class="tab-number" x-text="index + 1"></span>
                            <span class="tab-label" x-text="step.title || `Step ${index + 1}`"></span>
                        </button>
                    </template>
                </div>
            </div>

            <!-- Center Panel: Status/Preview (Fork mode with SVG/canvas preview) -->
            <div class="center-panel" style="background: #1a1a1a; position: relative; display: flex; flex-direction: column; align-items: center; justify-content: center; overflow: hidden;">
                <!-- SVG Preview Container (scalable, layered map preview) -->
                <!-- FIX 2: Removed x-html binding to bypass Alpine.js synchronous parsing - SVG is inserted directly via JS -->
                <div id="map-preview" class="svg-preview" x-show="previewMode === 'svg' && previewSvg" style="width: 100%; height: 100%; overflow: auto; background: #0a0a0a;"></div>
                <!-- Canvas for Azgaar preview rendering (fallback, shown when rendered) -->
                <canvas id="azgaar-canvas" x-show="previewMode === 'canvas' && previewImageUrl" style="width: 100%; height: 100%; object-fit: contain; background: #0a0a0a; display: none;"></canvas>
                <!-- Preview image (fallback if canvas not available, from Godot conversion) -->
                <img id="map-preview-img" x-show="previewMode === 'canvas' && previewImageUrl" :src="previewImageUrl" style="width: 100%; height: 100%; object-fit: contain;" alt="Map Preview">
                <!-- Preview Mode Toggle (shown when preview is available) -->
                <div x-show="(previewSvg || previewImageUrl) && !isGenerating" style="position: absolute; top: 10px; right: 10px; z-index: 10;">
                    <button @click="togglePreviewMode()" class="preview-toggle-button" style="padding: 0.5rem 1rem; background: rgba(0, 0, 0, 0.7); color: #fff; border: 1px solid #666; border-radius: 4px; cursor: pointer;">
                        <span x-text="previewMode === 'svg' ? 'Switch to Canvas' : 'Switch to SVG'"></span>
                    </button>
                </div>
                <!-- Status message (shown when no preview) -->
                <div id="azgaar-status" x-show="!previewSvg && !previewImageUrl" style="padding: 2rem; text-align: center; color: #aaa; font-size: 1.2em;">
                    <p x-text="statusText || 'Azgaar Genesis Fork - Ready'"></p>
                    <p style="font-size: 0.8em; margin-top: 1rem; color: #666;" x-show="!isGenerating">Using modular API - Generate a map to see preview</p>
                </div>
            </div>

            <!-- Right Panel: Parameters (Floating Panel Style) -->
            <div class="right-panel">
                <div class="right-outer-vbox">
                    <!-- Archetype Selector (Top) -->
                    <div class="archetype-selector">
                        <label>Archetype:</label>
                        <select x-model="archetype" @change="loadArchetype($event.target.value)">
                            <template x-for="arch in archetypeNames" :key="arch">
                                <option :value="arch" x-text="arch"></option>
                            </template>
                        </select>
                    </div>

                    <!-- Step Title -->
                    <div class="step-title-section">
                        <h2 class="step-title" x-text="currentStepTitle"></h2>
                    </div>

                    <!-- Parameters Tree (Step-specific curated parameters) -->
                    <div class="param-scroll">
                        <!-- Empty Step Info Text -->
                        <div x-show="currentStepParams.length === 0 && currentStepInfoText" class="empty-step-info">
                            <p class="info-text" x-text="currentStepInfoText"></p>
                        </div>
                        
                        <!-- Parameters List -->
                        <div class="param-list" x-show="currentStepParams.length > 0">
                            <template x-for="param in currentStepParams" :key="param.azgaar_key">
                                <div class="param-row">
                                    <label class="param-label" :title="param.description || ''" x-text="(param.name || param.azgaar_key).replace(/([A-Z])/g, ' $1').trim() + ':'"></label>
                                    <div class="param-control">
                                        <!-- OptionButton -->
                                        <template x-if="param.ui_type === 'OptionButton'">
                                            <select 
                                                x-model="params[param.azgaar_key]"
                                                @change="updateParam(param.azgaar_key, $event.target.value)">
                                                <template x-for="opt in param.options" :key="opt">
                                                    <option :value="opt" x-text="opt"></option>
                                                </template>
                                            </select>
                                        </template>

                                        <!-- HSlider -->
                                        <template x-if="param.ui_type === 'HSlider'">
                                            <div class="slider-container">
                                                <input 
                                                    type="range" 
                                                    x-model.number="params[param.azgaar_key]"
                                                    @input="updateParam(param.azgaar_key, parseFloat($event.target.value))"
                                                    :min="param.clamped_min !== undefined ? param.clamped_min : (param.min || 0)"
                                                    :max="param.clamped_max !== undefined ? param.clamped_max : (param.max || 100)"
                                                    :step="param.step || 1">
                                                <span class="slider-value" x-text="params[param.azgaar_key] || param.default || 0"></span>
                                            </div>
                                        </template>

                                        <!-- SpinBox -->
                                        <template x-if="param.ui_type === 'SpinBox'">
                                            <input 
                                                type="number" 
                                                x-model.number="params[param.azgaar_key]"
                                                @change="updateParam(param.azgaar_key, parseFloat($event.target.value))"
                                                :min="param.min"
                                                :max="param.max"
                                                :step="param.step || 1">
                                        </template>

                                        <!-- CheckBox -->
                                        <template x-if="param.ui_type === 'CheckBox'">
                                            <input 
                                                type="checkbox" 
                                                x-model="params[param.azgaar_key]"
                                                @change="updateParam(param.azgaar_key, $event.target.checked)">
                                        </template>
                                    </div>
                                </div>
                            </template>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Bottom Bar: Navigation & Generate -->
        <div class="bottom-bar">
            <button class="nav-button" @click="previousStep()" :disabled="currentStep === 0">Previous</button>
            <button class="nav-button" @click="nextStep()" :disabled="currentStep >= totalSteps - 1">Next</button>
            <button class="generate-button" @click="generate()" :disabled="isGenerating">
                <span x-show="!isGenerating">Generate Map</span>
                <span x-show="isGenerating">Generating...</span>
            </button>
            <div class="progress-container" x-show="isGenerating">
                <div class="progress-bar" :style="'width: ' + progressValue + '%'"></div>
                <span class="progress-text" x-text="statusText || 'Generating...'"></span>
            </div>
        </div>
    </div>

    <!-- Azgaar Genesis Fork Integration (Clean Integration - January 2026) -->
    <script type="module">
        /**
         * Azgaar Genesis Fork Integration - Clean Integration (January 2026)
         * Uses modular ESM API - no iframe, no bundle, no repair workarounds
         * Assumes fork provides complete pack.cells.v data structure
         */
        
        // Safety override for accidental large array logging (prevents console overflow)
        const originalLog = console.log;
        const originalError = console.error;
        const originalWarn = console.warn;
        
        console.log = function(...args) {
            const safeArgs = args.map(arg => {
                if (Array.isArray(arg) && arg.length > 100) {
                    return `[Large Array: ${arg.length} items, sample: ${JSON.stringify(arg.slice(0, 5))}...]`;
                }
                if (arg && typeof arg === 'object' && arg.constructor && arg.constructor.name === 'Uint16Array' && arg.length > 100) {
                    return `[TypedArray (${arg.constructor.name}): ${arg.length} items, sample: ${Array.from(arg.slice(0, 5)).join(',')}...]`;
                }
                if (arg && typeof arg === 'object' && arg.constructor && arg.constructor.name === 'Uint8Array' && arg.length > 100) {
                    return `[TypedArray (${arg.constructor.name}): ${arg.length} items, sample: ${Array.from(arg.slice(0, 5)).join(',')}...]`;
                }
                return arg;
            });
            originalLog.apply(console, safeArgs);
        };
        
        console.error = function(...args) {
            const safeArgs = args.map(arg => {
                if (Array.isArray(arg) && arg.length > 100) {
                    return `[Large Array: ${arg.length} items, sample: ${JSON.stringify(arg.slice(0, 5))}...]`;
                }
                if (arg && typeof arg === 'object' && arg.constructor && arg.constructor.name === 'Uint16Array' && arg.length > 100) {
                    return `[TypedArray (${arg.constructor.name}): ${arg.length} items, sample: ${Array.from(arg.slice(0, 5)).join(',')}...]`;
                }
                return arg;
            });
            originalError.apply(console, safeArgs);
        };
        
        console.warn = function(...args) {
            const safeArgs = args.map(arg => {
                if (Array.isArray(arg) && arg.length > 100) {
                    return `[Large Array: ${arg.length} items, sample: ${JSON.stringify(arg.slice(0, 5))}...]`;
                }
                if (arg && typeof arg === 'object' && arg.constructor && arg.constructor.name === 'Uint16Array' && arg.length > 100) {
                    return `[TypedArray (${arg.constructor.name}): ${arg.length} items, sample: ${Array.from(arg.slice(0, 5)).join(',')}...]`;
                }
                return arg;
            });
            originalWarn.apply(console, safeArgs);
        };
        
        // Import Delaunator (peer dependency) from local file (January 2026 fork build)
        import Delaunator from '../js/azgaar/delaunator.esm.js';
        
        // Import Azgaar Genesis library (updated fork - January 2026)
        // Assumes fork provides complete pack.cells.v with full polygon data
        import { 
            initGenerator, 
            loadOptions, 
            generateMap, 
            getMapData, 
            renderPreview,
            renderPreviewSVG 
        } from '../js/azgaar/azgaar-genesis.esm.js';

        // Initialize generator with canvas for preview rendering
        const canvas = document.getElementById('azgaar-canvas');
        function resizeCanvas() {
            if (canvas) {
                const container = canvas.parentElement;
                if (container) {
                    canvas.width = container.clientWidth;
                    canvas.height = container.clientHeight;
                    console.log('[Azgaar Genesis] Canvas resized', { width: canvas.width, height: canvas.height });
                }
            }
        }
        
        try {
            if (canvas) {
                // Set initial canvas size
                resizeCanvas();
                
                // Resize on window resize
                window.addEventListener('resize', resizeCanvas);
                
                // Validate canvas before initialization
                if (!canvas.getContext) {
                    console.warn('[Azgaar Genesis] Canvas element found but getContext not available');
                }
                
                initGenerator({ canvas: canvas });
                console.log('[Azgaar Genesis] Generator initialized with canvas');
                
                // Explicitly check and log canvas state after initGenerator
                // Note: state may not be immediately accessible from module, check canvas element directly
                const canvasValid = canvas && typeof canvas.toDataURL === 'function';
                // Try to access state after initialization (may not be available immediately)
                let stateCanvasSet = false;
                if (window.AzgaarGenesis && window.AzgaarGenesis.state) {
                    stateCanvasSet = !!window.AzgaarGenesis.state.canvas;
                }
                console.log('[Genesis Azgaar] Canvas initialized:', {
                    canvasElement: !!canvas,
                    canvasToDataURL: canvasValid,
                    stateCanvas: stateCanvasSet
                });
                
                if (!canvasValid) {
                    console.warn('[Genesis Azgaar] Canvas element invalid - canvas rendering will not be available');
                }
            } else {
                console.warn('[Azgaar Genesis] Canvas element not found - canvas rendering will not be available');
                initGenerator({ canvas: null }); // Fallback to headless
                console.log('[Azgaar Genesis] Generator initialized (headless mode - no canvas)');
            }
        } catch (error) {
            console.error('[Azgaar Genesis] Initialization error:', error);
            // Send error to Godot
            if (window.GodotBridge && window.GodotBridge.postMessage) {
                window.GodotBridge.postMessage('map_generation_failed', {
                    error: 'Fork initialization failed: ' + error.message,
                    stack: error.stack
                });
            }
        }
        
        // Store generator functions globally for Alpine.js access
        window.AzgaarGenesis = {
            Delaunator,
            loadOptions,
            generateMap,
            getMapData,
            renderPreview,
            renderPreviewSVG,
            initialized: true
        };
        
        console.log('[Azgaar Genesis] Library loaded and ready');
        
        // Notify Godot that fork is ready via IPC
        if (window.GodotBridge && window.GodotBridge.postMessage) {
            window.GodotBridge.postMessage('fork_ready', {});
            console.log('[Azgaar Genesis] Sent fork_ready IPC message to Godot');
        } else {
            console.warn('[Azgaar Genesis] GodotBridge.postMessage not available - cannot notify Godot');
        }
        
        // Listen for IPC messages from Godot
        if (window.GodotBridge && window.GodotBridge.onMessage) {
            window.GodotBridge.onMessage((message) => {
                console.log('[Azgaar Genesis] Received message from Godot:', message);
                if (message.type === 'generate_map') {
                    handleGenerateMap(message.options || {});
                }
            });
        } else {
            console.warn('[Azgaar Genesis] GodotBridge.onMessage not available');
        }
        
        /**
         * Handle map generation request
         */
        async function handleGenerateMap(options) {
            const statusDiv = document.getElementById('azgaar-status');
            const canvas = document.getElementById('azgaar-canvas');
            const { Delaunator, loadOptions, generateMap, getMapData, renderPreview } = window.AzgaarGenesis;
            
            if (!window.AzgaarGenesis.initialized) {
                console.error('[Azgaar Genesis] Generator not initialized');
                statusDiv.innerHTML = '<p style="color: #f44;">Error: Generator not initialized</p>';
                return;
            }
            
            try {
                statusDiv.innerHTML = '<p>Loading options...</p>';
                console.log('[Azgaar Genesis] Loading options:', options);
                
                loadOptions(options);
                
                statusDiv.innerHTML = '<p>Generating map...</p>';
                console.log('[Azgaar Genesis] Starting generation...');
                
                const startTime = performance.now();
                const data = generateMap(Delaunator);
                const generateTime = performance.now() - startTime;
                
                console.log('[Azgaar Genesis] Generation complete:', {
                    seed: data.seed,
                    time: generateTime.toFixed(2) + 'ms'
                });
                
                statusDiv.innerHTML = '<p>Extracting JSON data...</p>';
                const json = getMapData();
                
                console.log('[Azgaar Genesis] JSON extracted:', {
                    size: JSON.stringify(json).length,
                    hasGrid: !!json.grid,
                    hasPack: !!json.pack
                });
                
                // Render preview (SVG forced by default, canvas fallback only on error)
                let previewDataUrl = '';
                let previewSvgString = '';
                const useSvg = options.use_svg !== false && options.use_svg !== undefined ? options.use_svg : true; // Default to true (forced SVG mode)
                const DEBUG_RENDERING = false; // Set to true for verbose rendering logs
                
                // Validate map data before rendering (clean fork - no repair workarounds)
                // Updated fork (January 2026) should provide complete pack.cells.v structure
                let validation = validateMapData(json);
                
                // If validation fails, send error and skip rendering (no repair attempts)
                if (!validation.valid) {
                    console.error('[Azgaar Genesis] Data validation failed - fork should provide complete data:', validation.errors);
                    if (window.GodotBridge && window.GodotBridge.postMessage) {
                        window.GodotBridge.postMessage('render_failed', {
                            type: 'validation',
                            error: 'Data validation failed: ' + validation.errors.join('; '),
                            validationErrors: validation.errors
                        });
                    }
                    statusDiv.innerHTML = '<p style="color: #f44;">Error: Data validation failed - fork may need update</p>';
                    return; // Exit early, do not attempt rendering
                } else if (DEBUG_RENDERING) {
                    console.log('[Azgaar Genesis] Data validation passed');
                }
                
                // Force SVG rendering (default enabled)
                if (useSvg && window.AzgaarGenesis.renderPreviewSVG) {
                    try {
                        statusDiv.innerHTML = '<p>Rendering SVG preview...</p>';
                        if (DEBUG_RENDERING) {
                            console.log('[Azgaar Genesis] Rendering SVG preview (forced mode)...', { useSvg, hasFunction: !!window.AzgaarGenesis.renderPreviewSVG });
                        }
                        
                        // Re-validate right before rendering (data should already be valid, but double-check)
                        const preRenderValidation = validateMapData(json);
                        if (!preRenderValidation.valid) {
                            throw new Error('Pre-render validation failed: ' + preRenderValidation.errors.join(', '));
                        }
                        
                        const svgContainer = document.getElementById('map-preview');
                        if (!svgContainer) {
                            throw new Error('SVG container element not found');
                        }
                        
                        // Clear previous content
                        svgContainer.innerHTML = '';
                        
                        // Calculate dimensions (reduced defaults for testing - 960x540 per validation-metrics.md)
                        const containerRect = svgContainer.getBoundingClientRect();
                        const width = containerRect.width > 0 ? containerRect.width : (options.mapWidth || 960);
                        const height = containerRect.height > 0 ? containerRect.height : (options.mapHeight || 540);
                        
                        if (DEBUG_RENDERING) {
                            console.log('[Azgaar Genesis] SVG container dimensions:', { width, height, containerWidth: containerRect.width, containerHeight: containerRect.height });
                        }
                        
                        // Render SVG to container
                        const svgOptions = {
                            container: svgContainer,
                            width: Math.max(width, 512),  // Ensure minimum size
                            height: Math.max(height, 384)
                        };
                        
                        // Call renderPreviewSVG - it should append to container or return string
                        const svgStartTime = performance.now();
                        console.log('[Azgaar Genesis] Starting SVG rendering...', {
                            containerReady: !!svgContainer,
                            width: svgOptions.width,
                            height: svgOptions.height
                        });
                        
                        const svgResult = window.AzgaarGenesis.renderPreviewSVG(svgOptions);
                        const svgGenTime = performance.now() - svgStartTime;
                        
                        // Extract SVG string from container (function appends to container)
                        if (svgContainer.firstChild || svgContainer.innerHTML) {
                            previewSvgString = svgContainer.innerHTML;
                            console.log('[Azgaar Genesis] SVG extracted from container, length:', previewSvgString.length, 'gen time:', svgGenTime.toFixed(2) + 'ms');
                        } else if (typeof svgResult === 'string' && svgResult.length > 0) {
                            // Function returned SVG string directly
                            previewSvgString = svgResult;
                            console.log('[Azgaar Genesis] SVG returned as string, length:', previewSvgString.length, 'gen time:', svgGenTime.toFixed(2) + 'ms');
                        }
                        
                        if (previewSvgString && previewSvgString.length > 0) {
                            console.log('[Azgaar Genesis] SVG string received, length:', previewSvgString.length);
                            
                            // FIX 2: Direct DOM manipulation - bypass Alpine.js x-html binding to avoid blocking
                            // This prevents Alpine.js from synchronously parsing the large SVG string
                            statusDiv.innerHTML = '<p>Inserting SVG into DOM...</p>';
                            const domStartTime = performance.now();
                            
                            // Directly set innerHTML (bypass Alpine reactivity)
                            svgContainer.innerHTML = previewSvgString;
                            const domTime = performance.now() - domStartTime;
                            console.log('[Azgaar Genesis] DOM insert complete, time:', domTime.toFixed(2) + 'ms');
                            
                            // Update Alpine.js component state only (for UI state tracking, not rendering)
                            // Use requestAnimationFrame to defer reactivity updates
                            if (window.worldBuilderInstance) {
                                requestAnimationFrame(() => {
                                    // Update state without triggering x-html binding
                                    // The SVG is already in the DOM, so we just update flags
                                    window.worldBuilderInstance.previewSvg = previewSvgString; // For state tracking only
                                    window.worldBuilderInstance.previewMode = 'svg';
                                    // Force visibility update
                                    if (svgContainer.style) {
                                        svgContainer.style.display = 'block';
                                    }
                                    console.log('[Azgaar Genesis] Alpine.js state updated (deferred)');
                                });
                            }
                            
                            // Send SVG data to Godot via IPC
                            if (window.GodotBridge && window.GodotBridge.postMessage) {
                                const totalTime = performance.now() - svgStartTime;
                                window.GodotBridge.postMessage('svg_preview_ready', {
                                    svgData: previewSvgString,
                                    width: svgOptions.width,
                                    height: svgOptions.height,
                                    renderTime: totalTime
                                });
                                console.log('[Azgaar Genesis] Sent svg_preview_ready IPC message', {
                                    svgLength: previewSvgString.length,
                                    totalTime: totalTime.toFixed(2) + 'ms',
                                    genTime: svgGenTime.toFixed(2) + 'ms',
                                    domTime: domTime.toFixed(2) + 'ms'
                                });
                            }
                            
                            statusDiv.innerHTML = '<p style="color: #4f4;">SVG preview ready!</p>';
                        } else {
                            throw new Error('SVG rendering returned empty result');
                        }
                    } catch (svgError) {
                        console.error('[Azgaar Genesis] SVG preview render failed:', svgError.message, svgError.stack);
                        // Notify Godot of SVG failure with detailed error info
                        if (window.GodotBridge && window.GodotBridge.postMessage) {
                            window.GodotBridge.postMessage('render_failed', {
                                type: 'svg',
                                error: svgError.message,
                                stack: svgError.stack,
                                validationErrors: validation.valid ? [] : validation.errors
                            });
                            // Also send legacy svg_failed for compatibility
                            window.GodotBridge.postMessage('svg_failed', {
                                error: svgError.message,
                                stack: svgError.stack
                            });
                        }
                        // Fall through to canvas rendering as fallback
                        console.warn('[Azgaar Genesis] Falling back to canvas rendering due to SVG failure');
                    }
                } else if (!useSvg) {
                    console.log('[Azgaar Genesis] SVG rendering disabled by options.use_svg = false');
                } else if (!window.AzgaarGenesis.renderPreviewSVG) {
                    console.error('[Azgaar Genesis] renderPreviewSVG function not available');
                }
                
                // Fallback to canvas rendering (only if SVG explicitly failed AND validation passed)
                // DEPRECATED: Canvas is unreliable in Godot WebView - deprioritize it
                // Only attempt canvas if SVG failed AND validation passed AND canvas is available
                const ENABLE_CANVAS_FALLBACK = false; // Disabled due to WebView canvas limitations
                const canvasAvailable = canvas && typeof canvas.toDataURL === 'function';
                
                if (!previewSvgString && ENABLE_CANVAS_FALLBACK && canvasAvailable && validation.valid && window.AzgaarGenesis.renderPreview) {
                    try {
                        statusDiv.innerHTML = '<p>Rendering canvas preview (legacy fallback)...</p>';
                        console.warn('[Azgaar Genesis] Using deprecated canvas rendering fallback (SVG preferred)');
                        
                        // Re-validate data before canvas rendering
                        const preCanvasValidation = validateMapData(json);
                        if (!preCanvasValidation.valid) {
                            throw new Error('Pre-canvas validation failed: ' + preCanvasValidation.errors.join(', '));
                        }
                        
                        // Check if canvas is properly initialized (may not be set in state due to WebView limitations)
                        const state = window.AzgaarGenesis?.state;
                        if (!state || !state.canvas) {
                            console.warn('[Azgaar Genesis] Canvas not set in state (WebView limitation), attempting renderPreview anyway');
                            // Don't throw - try anyway since canvas element exists
                        }
                        
                        window.AzgaarGenesis.renderPreview();
                        previewDataUrl = canvas.toDataURL('image/png');
                        
                        if (!previewDataUrl || previewDataUrl.length === 0) {
                            throw new Error('Canvas toDataURL returned empty result');
                        }
                        
                        // Show canvas after rendering
                        canvas.style.display = 'block';
                        if (statusDiv) {
                            statusDiv.style.display = 'none';
                        }
                        console.log('[Azgaar Genesis] Canvas preview rendered (fallback), data URL length:', previewDataUrl.length);
                        
                        // Update Alpine.js component
                        if (window.worldBuilderInstance) {
                            window.worldBuilderInstance.previewMode = 'canvas';
                            window.worldBuilderInstance.previewImageUrl = previewDataUrl;
                        }
                    } catch (renderError) {
                        console.error('[Azgaar Genesis] Canvas preview render failed:', renderError.message, renderError.stack);
                        // Notify Godot of canvas failure with detailed error info
                        if (window.GodotBridge && window.GodotBridge.postMessage) {
                            window.GodotBridge.postMessage('render_failed', {
                                type: 'canvas',
                                error: renderError.message,
                                stack: renderError.stack,
                                validationErrors: validation.valid ? [] : validation.errors
                            });
                        }
                        statusDiv.innerHTML = '<p style="color: #f44;">Error: Canvas rendering failed (fallback)</p>';
                    }
                } else if (!previewSvgString && useSvg) {
                    // SVG was requested but failed
                    if (!ENABLE_CANVAS_FALLBACK || !canvasAvailable) {
                        console.error('[Azgaar Genesis] SVG rendering failed and canvas fallback disabled/unavailable');
                        statusDiv.innerHTML = '<p style="color: #f44;">Error: SVG rendering failed (canvas fallback disabled)</p>';
                    } else if (!validation.valid) {
                        console.error('[Azgaar Genesis] SVG rendering failed and validation failed, skipping canvas fallback');
                        statusDiv.innerHTML = '<p style="color: #f44;">Error: SVG rendering failed (data validation failed, cannot use canvas fallback)</p>';
                    } else {
                        console.error('[Azgaar Genesis] SVG rendering failed but canvas fallback should have been attempted');
                        statusDiv.innerHTML = '<p style="color: #f44;">Error: SVG rendering failed</p>';
                    }
                }
                
                // Send to Godot via IPC (with preview if available)
                if (window.GodotBridge && window.GodotBridge.postMessage) {
                    window.GodotBridge.postMessage('map_generated', {
                        data: json,
                        seed: data.seed,
                        generationTime: generateTime,
                        previewDataUrl: previewDataUrl,
                        previewSvg: previewSvgString || null
                    });
                    console.log('[Azgaar Genesis] Sent map_generated message to Godot', {
                        hasCanvasPreview: previewDataUrl.length > 0,
                        hasSvgPreview: previewSvgString.length > 0
                    });
                } else {
                    console.warn('[Azgaar Genesis] GodotBridge.postMessage not available');
                }
                
                // Preview is now visible via canvas rendering
                // Alpine.js will handle showing/hiding based on previewImageUrl
                console.log('[Azgaar Genesis] Generation and preview complete');
            } catch (error) {
                console.error('[Azgaar Genesis] Generation error:', error);
                statusDiv.innerHTML = `
                    <p style="color: #f44;">Error: ${error.message}</p>
                    <p style="font-size: 0.8em; color: #aaa; margin-top: 0.5rem;">${error.stack || ''}</p>
                `;
                
                // Send error to Godot
                if (window.GodotBridge && window.GodotBridge.postMessage) {
                    window.GodotBridge.postMessage('map_generation_failed', {
                        error: error.message,
                        stack: error.stack
                    });
                }
            }
        }
        
        /**
         * Validate map data structure before rendering with deep integrity checks
         * Returns {valid: boolean, errors: string[]}
         */
        function validateMapData(data) {
            const errors = [];
            if (!data?.pack) {
                errors.push('Missing pack object');
                return {valid: false, errors};
            }
            const {cells, vertices} = data.pack;
            
            // Check cells structure with length validation
            if (!cells) {
                errors.push('Missing pack.cells');
                return {valid: false, errors};
            }
            
            if (!cells.i || !Array.isArray(cells.i) || cells.i.length === 0) {
                errors.push('cells.i empty or missing');
            }
            
            const expectedLength = cells.i ? cells.i.length : 0;
            
            // Validate cells.v - critical for SVG rendering (causes "undefined is not an object" errors)
            if (!cells.v || !Array.isArray(cells.v)) {
                errors.push('cells.v missing or not an array');
            } else if (cells.v.length !== expectedLength) {
                errors.push(`cells.v length mismatch (${cells.v.length} vs ${expectedLength})`);
            } else {
                // Check for undefined holes in cells.v array (critical for SVG rendering)
                for (let i = 0; i < Math.min(cells.v.length, 1000); i++) { // Limit check to first 1000 to avoid performance issues
                    if (cells.v[i] === undefined) {
                        errors.push(`cells.v[${i}] undefined`);
                        break; // Report first undefined entry
                    }
                }
            }
            
            // Validate cells.c
            if (!cells.c || !Array.isArray(cells.c)) {
                errors.push('cells.c missing or not an array');
            } else if (cells.c.length !== expectedLength) {
                errors.push(`cells.c length mismatch (${cells.c.length} vs ${expectedLength})`);
            }
            
            // Validate cells.biome (required for SVG rendering)
            if (!cells.biome || !Array.isArray(cells.biome)) {
                errors.push('cells.biome missing or not an array (required for SVG rendering)');
            } else if (cells.biome.length !== expectedLength) {
                errors.push(`cells.biome length mismatch (${cells.biome.length} vs ${expectedLength})`);
            }
            
            // Validate cells.state (required for SVG rendering)
            if (!cells.state || !Array.isArray(cells.state)) {
                errors.push('cells.state missing or not an array (required for SVG rendering)');
            } else if (cells.state.length !== expectedLength) {
                errors.push(`cells.state length mismatch (${cells.state.length} vs ${expectedLength})`);
            }
            
            // Check vertices structure
            if (!vertices) {
                errors.push('Missing pack.vertices');
            } else {
                if (!vertices.c || typeof vertices.c !== 'object') {
                    errors.push('Missing or invalid vertices.c (required for isolines)');
                }
                if (!vertices.p || !Array.isArray(vertices.p)) {
                    errors.push('Missing or invalid vertices.p (required for isolines)');
                }
            }
            
            return {valid: errors.length === 0, errors};
        }
        
        // repairMapData function removed - clean fork (January 2026) should provide complete data
        // No repair workarounds needed
        
        // Make handleGenerateMap available globally for direct calls
        window.handleGenerateMap = handleGenerateMap;
    </script>
    
    <!-- Alpine.js World Builder Controller -->
    <script src="../js/world_builder.js"></script>
</body>
</html>
